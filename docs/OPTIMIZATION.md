# Оптимизация производительности

В этом документе описаны инструменты и методы, используемые для оптимизации производительности приложения.

## Сборка и оптимизация ресурсов (Vite)

Настройки сборки в `vite.config.js` включают:

### Оптимизация изображений
- Используется `vite-plugin-imagemin` для автоматического сжатия всех изображений при сборке
- Поддерживает форматы JPG, PNG, GIF, SVG, WEBP
- Настроен оптимальный баланс между качеством и размером файлов

### Сжатие ресурсов
- Используется `vite-plugin-compression` для создания сжатых версий ресурсов
- Поддерживается gzip и brotli сжатие
- Сервер должен быть настроен для отдачи сжатых версий файлов

### Разделение кода
- Используется автоматическое разделение кода на чанки 
- Оптимизировано хеширование файлов для эффективного кеширования
- Вендорные пакеты (React, иконки и т.д.) выделены в отдельные файлы

### Совместимость с браузерами
- `@vitejs/plugin-legacy` обеспечивает поддержку старых браузеров
- Автоматически создаются полифиллы на основе настроенных целевых браузеров

### PWA поддержка
- Добавлена поддержка Progressive Web App
- Предварительное кеширование ключевых ресурсов для быстрой загрузки даже офлайн

## Оптимизация изображений на клиенте

Утилита `src/utils/imageCompression.js` предоставляет инструменты для оптимизации изображений перед загрузкой на сервер:

```javascript
import { compressImage } from '../utils/imageCompression';

// В обработчике загрузки файла
async function handleFileUpload(event) {
  const file = event.target.files[0];
  
  // Сжимаем изображение перед загрузкой
  const optimizedFile = await compressImage(file, {
    maxSizeMB: 0.5,
    maxWidthOrHeight: 1200
  });
  
  // Загружаем оптимизированный файл на сервер
  uploadToServer(optimizedFile);
}
```

### Возможности клиентской оптимизации:

1. **Сжатие изображений**:
   - Уменьшение размера файла при сохранении приемлемого качества
   - Адаптивная компрессия в зависимости от исходного размера
   - Пропуск сжатия для уже оптимизированных или анимированных изображений

2. **Изменение размера и конвертация**:
   - Изменение размера слишком больших изображений
   - Автоматическая конвертация в WebP для поддерживаемых браузеров
   - Сохранение соотношения сторон при изменении размера

## Оптимизация рендеринга в React

### Техники для улучшения производительности:

1. **Мемоизация компонентов**:
   - Использование React.memo для предотвращения ненужных ререндеров
   - Правильное использование useMemo и useCallback для оптимизации вычислений

2. **Ленивая загрузка компонентов**:
   ```javascript
   const LazyComponent = React.lazy(() => import('./LazyComponent'));
   
   function App() {
     return (
       <Suspense fallback={<Loading />}>
         <LazyComponent />
       </Suspense>
     );
   }
   ```

3. **Виртуализация списков**:
   - Для больших списков данных рекомендуется использовать библиотеки виртуализации
   - Рендеринг только видимых элементов списка

4. **Оптимизация изображений**:
   - Использование lazy loading для изображений
   - Указание размеров изображений для предотвращения перекомпоновки макета
   - Использование WebP с fallback на другие форматы

## Мониторинг производительности

Для анализа размера бандла используйте:

```bash
# Запуск анализа бандла
ANALYZE=true npm run build
```

Отчет будет доступен в файле `dist/stats.html` после завершения сборки.

## Проверка производительности

Для проверки производительности используйте:

1. **Lighthouse в Chrome DevTools**
2. **PageSpeed Insights** (https://pagespeed.web.dev/)
3. **WebPageTest** (https://www.webpagetest.org/)

## Лучшие практики

1. Всегда сжимайте изображения перед загрузкой
2. Используйте мемоизацию для предотвращения ненужных ререндеров
3. Разделяйте крупные компоненты на более мелкие и подгружайте их лениво
4. Регулярно проводите аудит производительности приложения
5. Используйте инструменты DevTools для поиска узких мест 